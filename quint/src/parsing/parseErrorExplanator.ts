/*
 * A syntax error explanation framework.
 *
 * Igor Konnov, Informal Systems, 2023
 *
 * Licensed under the Apache 2.0.
 * See License.txt in the project root for license information.
 */

import { BailErrorStrategy, CharStreams, CommonTokenStream, InputMismatchException, LexerNoViableAltException, NoViableAltException, RecognitionException } from "antlr4ts";
import * as p from '../generated/QuintErrorsParser'
import { QuintErrorsLexer } from "../generated/QuintErrorsLexer";
import { ParseCancellationException } from "antlr4ts/misc/ParseCancellationException";
import { ErrorCode, QuintError } from "../quintError";
import { SourceMap } from "./quintParserFrontend";
import { IdGenerator } from "../idGenerator";
import { Interval } from "antlr4ts/misc/Interval";
import { Loc, Position } from "../ErrorMessage";

/**
 * The type of the starting non-terminal for the parser.
 */
export type startNonTerminal = 'modules' | 'declarationOrExpr'

/**
 * Run a second parser to explain lexical and syntax errors in more detail.
 * @param text the original source code
 * @param goal the starting non-terminal
 * @param sourceLocation 
 * @param sourceMap 
 * @param idGen 
 * @returns 
 */
export function explainParseErrors(
    text: string,
    goal: startNonTerminal,
    mkIdForLoc: (start: Position, end: Position) => bigint,
  ): QuintError[] {
  const errors: QuintError[] = []
  const errorListener: any = {
    syntaxError: (_recognizer: any, offendingSymbol: any, line: number,
        charPositionInLine: number, msg: string, exc: RecognitionException) => {
      const len = offendingSymbol ? offendingSymbol.stopIndex - offendingSymbol.startIndex : 0
      const index: number = offendingSymbol ? offendingSymbol.startIndex : 0
      const start = { line: line - 1, col: charPositionInLine, index }
      const end = { line: line - 1, col: charPositionInLine + len, index: index + len }
      const id = mkIdForLoc(start, end)
      if (exc instanceof LexerNoViableAltException) {
        // This error is reported when the lexer is not able to convert a character
        // to a token.
        const text = exc.inputStream.getText(new Interval(exc.startIndex, exc.startIndex))
        const message = `unexpected character: '${text}'`
        errors.push({ code: 'QNT000', message: message, reference: id })
        return
      }
      if (exc instanceof NoViableAltException) {
        // This is an error reported by the parser when it cannot match the tokens.
        if (exc.getOffendingToken()) {
          let input = exc.getOffendingToken()?.text
          input = (input === '<EOF>') ? 'end of file' : `'${input}'`
          errors.push({ code: 'QNT000', message: `unexpected ${input}`, reference: id })
          return
        }
      }
      // Use the default message that is propagated by the parser from the grammar,
      // or is generated by the parser.
      const code = (msg.match(/QNT\d\d\d/)?.[0] as ErrorCode) ?? 'QNT000'
      errors.push({ code, message: msg.replace(`[${code}] `, ''), reference: id })
    },
  }

  // Create the lexer and parser from the original text again.
  // Instead, we could collect a token stream from the upstream parser.
  // However, caching tokens is probably less efficient than parsing
  // the text again. It would be definitely inefficient to collect tokens,
  // when the text is recognized by the grammar.
  const inputStream = CharStreams.fromString(text)
  const lexer = new QuintErrorsLexer(inputStream)
  // remove the console listener, add our own error listener
  lexer.removeErrorListeners()
  lexer.addErrorListener(errorListener)

  const tokenStream = new CommonTokenStream(lexer)
  const parser = new p.QuintErrorsParser(tokenStream)

  // remove the console listener and add our listener
  parser.removeErrorListeners()
  // this still needs a listener, for the messages defined in the grammar
  parser.addErrorListener(errorListener)

  // Run the parser, ignore the result.
  // Since it is the second pass, we know that the parser must produce an error.
  switch (goal) {
    case 'modules':
      parser.modules()
      break

    case 'declarationOrExpr':
      parser.declarationOrExpr()
      break
  }

  return errors
}