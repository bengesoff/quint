// AUTOGENERATED FILE
// This file was generated from quint.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface QuintActionDict<T> extends BaseActionDict<T> {
  Modules?: (this: NonterminalNode, arg0: IterationNode) => T;
  Module?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: IterationNode, arg5: TerminalNode) => T;
  DocDefinition?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  Definition_constDef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Definition_varDef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Definition_assumeDef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Definition_importDef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode) => T;
  Definition_exportDef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode) => T;
  Definition_instanceDef?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Definition_operDef?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Definition_typeDef?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Definition?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  NameRef_identOrStarRef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  NameRef_asRef?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  NameRef?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DefinitionStart?: (this: NonterminalNode, arg0: TerminalNode) => T;
  FromFile_fromOk?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  FromFile_fromError?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  FromFile?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Instance?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: IterationNode, arg7: IterationNode, arg8: IterationNode, arg9: IterationNode, arg10: TerminalNode, arg11: NonterminalNode, arg12: IterationNode) => T;
  OperDef?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode) => T;
  OperParams_paramsC?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode, arg7: IterationNode, arg8: TerminalNode, arg9: TerminalNode, arg10: NonterminalNode) => T;
  OperParams_paramsMLnary?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode, arg5: IterationNode, arg6: IterationNode) => T;
  OperParams_paramsMLnullary?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  OperParams?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Parameter?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  NormalCallName?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  TypeDef_typeAlias?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  TypeDef_typeSumDef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: NonterminalNode, arg5: IterationNode, arg6: IterationNode) => T;
  TypeDef_typeAbstractDef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  TypeDef?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  TypeSumVariant?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode) => T;
  Type_funType?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Type_unaryOperType?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Type_naryOperType?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode, arg6: TerminalNode, arg7: NonterminalNode) => T;
  Type_setType?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  Type_listType?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  Type_tupleType?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode, arg7: TerminalNode) => T;
  Type_recordType?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Type_intType?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Type_strType?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Type_boolType?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Type_uninterpretedType?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Type_parenType?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Type?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Row?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode, arg7: IterationNode, arg8: IterationNode, arg9: IterationNode) => T;
  Qualifier_valQual?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Qualifier_defQual?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Qualifier_pureValQual?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  Qualifier_pureDefQual?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  Qualifier_actionQual?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Qualifier_runQual?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Qualifier_temporalQual?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Qualifier?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expr_ifElseExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode) => T;
  Expr_dotCallExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode, arg7: IterationNode) => T;
  Expr_lambdaExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expr_appExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode) => T;
  Expr_listAppExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  Expr_powExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_uminusExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  Expr_multDivExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_plusMinusExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_relationsExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_asgnExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Expr_naryAndExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Expr_andExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_orExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Expr_naryOrExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_iffExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_impliesExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_matchExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expr_allExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Expr_anyExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Expr_asgnError?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_falseExpr?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Expr_trueExpr?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Expr_tupleExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode) => T;
  Expr_pairExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_recordExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode) => T;
  Expr_listExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode) => T;
  Expr_letInExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  Expr_nondetExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  Expr_intExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expr_strExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expr_identExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expr_parenExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Expr_bracesExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Expr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  RecElem_keyValueExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  RecElem_spreadExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  RecElem?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MatchSum?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: NonterminalNode, arg5: IterationNode, arg6: IterationNode, arg7: TerminalNode) => T;
  MatchCase_labelMatch?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode) => T;
  MatchCase_underscoreMatch?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  MatchCase?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  NondetOperDef?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: IterationNode) => T;
  Lambda?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LambdaUnsugared_unaryLambda?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  LambdaUnsugared_naryLambda?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode, arg5: TerminalNode, arg6: NonterminalNode) => T;
  LambdaUnsugared?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LambdaTupleSugar?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode, arg6: TerminalNode, arg7: TerminalNode, arg8: NonterminalNode) => T;
  NameAfterDot?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  DocComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  QualId?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  string?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  doubleStringCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ident?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode, arg1: IterationNode) => T;
  identOrHole?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  identOrStar?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  integer?: (this: NonterminalNode, arg0: IterationNode) => T;
  lineTerminator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  space?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  whiteSpace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  multiLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  singleLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
}

export interface QuintSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: QuintActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: QuintActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: QuintActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: QuintActionDict<T>): this;
}

export interface QuintGrammar extends Grammar {
  createSemantics(): QuintSemantics;
  extendSemantics(superSemantics: QuintSemantics): QuintSemantics;
}

declare const grammar: QuintGrammar;
export default grammar;

